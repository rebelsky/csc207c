---
title: Learning Objectives and Learning Assessments
summary: What we expect you to learn
permalink: /los/
---
# {{ page.title }}

To directly assess your mastery of the learning objectives of this course, we will conduct a series of learning assessments over the course of the semester.
The use LAs of this course is inspired by [mastery-based testing](https://mbtmath.wordpress.com/) practices found in mathematics.

Most of the LAs will also appear as in-class paper-based ten-minute quizzes, given in class on various days.

Each LA will correspond to one of the learning objectives described below.

If you do not complete the learning assessment for a learning objective the first time, you will have multiple chances to retry. 

The objectives may change slightly during the semester as the schedule shifts.

## Object-Oriented Design

I expect that by the end of the semester, you will have mastered the basics of object-oriented design.  In particular, I expect that you will be able to

* describe and use four pillars of object-oriented design: 
    * encapsulation (_OOP LO #01: Encapsulation_),  
    * inheritance, representing a form of the **is-a** relationship (_OOP LO #02: Inheritance_), 
    * composition, representing a form of the **has-a** relationship (_OOP LO #03: Composition_), and
    * polymorphism, including both 
         * parametric polymorphism (_OOP LO #04: Parametric Polymorphism_) and
         * subtype polymorphism (_OOP LO #05: Subtype Polymorphism_);
* apply object-oriented design principles to separate interface from implentation (_OOP LO #06: Data Abstraction_)
* identify and use a variety of basic design patterns (_OOP LO: 07: Design Patterns_), such as Model-View-Controller, Factory, Singleton, Adapter, and Decorator;
* identify objects and classes that will contribute to a program or solution, design those objects and classes, and implement those objects and classes (_OOP LO #08: Object Design_); and
* describe a common layout of objects in memory (_OOP LO #09: Mental Models_).

## Design and Analysis of Algorithms

I expect that by the end of the semester, you will have significantly extended your skills in the design, implementation, and analysis of algorithms.  In particular, I expect that you will be able to

* describe and implement classic algorithms, including
    * binary search (_Algorithms LO #01: Binary Search_), 
    * sequential search (_Algorithms LO #02: Sequential Search_), 
    * insertion sort (_Algorithms LO #03: Insertion Sort_), 
    * selection sort (_Algorithms LO #04: Selection Sort_), 
    * heap sort (_Algorithms LO #05: Heap Sort_), 
    * Quicksort (_Algorithms LO #06: Quicksort_), 
    * merge sort (_Algorithms LO #07: Merge Sort_),
    * graph and tree traversal (_Algorithms LO #08: Traversal_), and
    * shortest path (_Algorithms LO #09: Shortest path_);
* design new algorithms using a variety of approaches including 
    * greed (_Algorithms LO #10: Greed_) and
    * divide and conquer (_Algorithms LO #11: Divide and Conquer_);
* read and interpret the formal definition of Big-O (_Algorithms LO #12: Big-O Notation_);
* informally analyze the running time of iterative algorithms and the number of steps in complex nested loops (_Algorithms LO #13: Analysis of Iterative Algorithms_);
* informally analyze the running time of recursive algorithms (_Algorithms LO #14: Analysis of Recursive Algorithms_);
* describe or use loop invariants to better design and verify iterative algorithms (_Algorithms LO #15: Loop Invariants_).

## Design and Analysis of Abstract Data Types and Data Structures

I expect that by the end of the semester, you will have significantly extended your skills in the design, implementation, and analysis of abstract data types and algorithms.  In particular, I expect that you will be able to

* describe and implement classic ADTs and data structures, including 
    * lists (_ADT/DS LO #01: Lists_), 
    * stacks (_ADT/DS LO #02: Stacks_),
    * queues (_ADT/DS LO #03: Queues_),
    * priority queues (_ADT/DS LO #04: Priority Queues_), 
    * dictionaries/maps (_ADT/DS LO #05: Dictionaries_), 
    * hash tables (_ADT/DS LO #06: Hash Tables_), 
    * binary search trees (_ADT/DS LO #07: BSTs_), 
    * heaps (_ADT/DS LO #08: Heaps_), and
    * graphs (_ADT/DS LO #09: Graphs_);
* implement one or more data types using arrays (_ADT/DS LO #10: Array-based Structures_);
* implement one or more data types using linked structures (_ADT/DS LO #11: Linked Structures_);
* design new ADTs using the PUM (philosophy, uses, methods) approach (_ADT/DS LO #12: Design ADTs_); 
* design new data structures using the LIA (layout, implement, analyze) approach (_ADT/DS LO #13: Design Data Structures_); and
* design, implement, and use iterators for one or more compound data types (_ADT/DS LO #14: Iterators_).

## Software Design and Development

I expect that by the end of the semester, you will be a competent beginning software developer.  In particular, in addition to having the skills described above, I expect that you will be able to

* work with one or more other students on the creation of a program (_Development LO #01: Collaboration_);
* manage development of multi-file programs in Java using a build tool (in our case, Maven) (_Development LO #02: Build Tools_);
* design, implement, and run unit tests (_Development LO #03: Unit Testing_);
* develop software using an integrated development environment (in our case, Visual Studio Code) (_Development LO #04: IDE_);
* collaborate on and keep track of the development history of code using a version control system* (in our case, Git) (_Development LO #05: Version Control_);
* read, understand, and modify code that you did not write (_Development LO #06: Code Reading_);
* exercise good practices in documenting code and create Javadoc documentation for Java programs (_Development LO #07: Documentation_);
* design and develop libraries for use in other programs (_Development LO #08: Build Libraries_);
* use libraries in your own programs (_Development LO #09: Use Libraries_); 
* signal and recover from errors using exceptions (_Development LO #10: Exceptions_);
* responsibly incorporate code that you did not write into your own program (_Development LO #11: Ethical Reuse_); and
* understand and explain the responsibilities of a software designer (_Development LO #12: Professional Ethics_).

