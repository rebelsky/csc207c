---
title: Mini-Project 6
subtitle: Sorting out sorting
summary: |
  In this assignment, you will further explore the implementation 
  of sorting algorithms.
repository: https://github.com/Grinnell-CSC207/sorting-mini-project
collaboration: |
  Each student should submit their own responses to this project. You may
  consult other students in the class as you develop your solution.  If you
  receive help from anyone, make sure to cite them in your responses. 
link: true
---
# {{ page.title }} : {{ page.subtitle }}

_This assignment is still in draft form._

Summary: {{ page.summary }}

Repository: <{{ page.repository }}>

## Background: A generic sorting interface

As you might expect, we want to be able to switch sorting algorithms depending on a variety of circumstances, particularly characteristics we know about the data (e.g., that they are mostly in order or perhaps mostly reverse sorted).  Hence, rather than writing static `sort` methods, it may be more useful to define a generic `Sorter` interface and use that.  You may even recall that we wrote such an interface.  Here's a slight variant of that interface.

```
/**
 * Things that know how to sort homogeneous collections.
 */
public interface Sorter {
  /**
   * Sort an array in place.
   *
   * @param vals, an array to sort.
   * @param order, the order by which to sort the values.
   * @return
   *    The same array, now sorted.
   * @pre
   *    order can be applied to any two values in vals.
   * @pre
   *    VALS = vals.
   * @post
   *    vals is a permutation of VALS.
   * @post
   *    For all i, 0 < i < vals.length,
   *      order.compare(vals[i-1], vals[i]) <= 0
   */
  public <T> void sort(T[] values, Comparator<? super T> order);
} // interface Sorter
```

## Part one: Testing

As I hope you know by now, when writing a small or medium-sized function or class, we should begin by writing test cases for the function or class.

In the file `SortTester.java`, add at least five test cases for `Sorter<T>` objects.

## Part two: Insertion sort.

Create a new class, `InsertionSort`, that implements insertion sort.  The repo should include a framework for the class.

## Part two: Merge sort

In class, you implemented (or started to implement) merge sort.  Create a new class, `MergeSort`, that implements merge sort.  The repo should include a framework for the class.

## Part three: Quicksort

In class, you implemented (or started to implement) Quicksort.  Create a new class, `QuickSort`, that implements Quicksort.  The repo should include a framework for the class.

## Part four: Your own sort

In practice, one of the most popular sorting algorithms in TimSort.  You should read [the original documentation for TimSort](https://github.com/python/cpython/blob/main/Objects/listsort.txt) as a starting point in understanding it (it's good practice to read the documentation that programmers write for other programmers), but you might find the [Wikipedia page](https://en.wikipedia.org/wiki/Timsort) a bit more comprehensible.

Using the ideas from TimSort and anything else you find, implement the fastest (in practice) sorting algorithm you can come up with.

We will hold a competition in class to see whose sorting algorithm wins on different kinds of inputs.  Winners will receive acclaim from their instructor, mentors, and classmates.

Please name your class `LastFirstSort`.  For example, mine would be `RebelskySamuelSort`.
